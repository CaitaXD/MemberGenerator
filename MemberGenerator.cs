using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using MemberGenerator.Ex;
using MemberGenerator.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MemberGenerator;

[Generator]
public class MemberGenerator : IIncrementalGenerator
{
    const string Namespace                           = "MemberGenerator";
    const string GenerateDefaultMembersAttributeName = "GenerateDefaultMembers";
    const string PassthroughAttribute =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              public class {{GenerateDefaultMembersAttributeName}}Attribute : System.Attribute
              {
              }
          };
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var sourceCode = SourceText.From(PassthroughAttribute, Encoding.UTF8);
            string checksum = FormatedChecksum(sourceCode, take: 4);
            string fileName = $"{GenerateDefaultMembersAttributeName}Attribute_{checksum}.g.cs";
            ctx.AddSource(fileName, sourceCode);
        });

        var interfacesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{Namespace}.{GenerateDefaultMembersAttributeName}Attribute",
                static (syntax, _) => syntax is InterfaceDeclarationSyntax,
                static (context, _) =>
                {
                    var declaration = (InterfaceDeclarationSyntax)context.TargetNode;
                    return declaration;
                }
            ).Collect();

        var usingDirectives = context.SyntaxProvider
            .CreateSyntaxProvider<UsingDirectiveSyntax>()
            .Collect();

        var interfaceImplementationMap = context.SyntaxProvider
            .CreateSyntaxProvider(static (syntax, _) => syntax is InterfaceDeclarationSyntax,
                static (context, _) => (context, node: (InterfaceDeclarationSyntax)context.Node)
            )
            .Combine(interfacesWithAttribute)
            .Select(static (state, cancellationToken) => (
                state.Left.context,
                interfaceSyntax: state.Left.node,
                parentInterfaces: ExtractParentInterfaces(
                    syntax: state.Left.node,
                    parentInterfaces: state.Right,
                    cancellationToken: cancellationToken
                )
            ))
            .Combine(usingDirectives)
            .Select(static (state, _) =>
            {
                var ((context, interfaceSyntax, parentInterfaces), usings) = state;
                var enumeratedParentInterfaces = parentInterfaces.ToReadonlyCollection();
                var concatenation = enumeratedParentInterfaces.Append(interfaceSyntax);

                var members = concatenation.GetDefaultMembers().ToReadonlyCollection();
                var intersection = usings.Select(s => s.SyntaxTree).Intersect(members.Select(x => x.SyntaxTree));
                return (
                    interfaceSyntax,
                    parentInterfaces: enumeratedParentInterfaces,
                    members,
                    usings: usings.Where(x => intersection.Contains(x.SyntaxTree)).ToImmutableArray()
                );
            })
            .Collect()
            .Select(static (state, _) =>
            {
                var members = state.ToImmutableDictionary(x => x.interfaceSyntax, x => x.members);
                var parents = state.SelectMany(s => s.parentInterfaces);
                var parentMembers = parents.Select(s => (s, s.GetDefaultMembers().ToReadonlyCollection()));
                var membersMap = members.Combine(parentMembers);
                return (membersMap, usings: state.SelectMany(x => x.usings).ToImmutableArray());
            });

        var partialTypeDeclarations =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (syntax, _) => syntax.IsPartialTypeDeclaration(),
                    static (context, _) => (TypeDeclarationSyntax)context.Node
                )
                .Collect()
                .Select(static (syntax, _) => syntax.GroupByToImmutableDictionary(syntax =>
                    syntax.Identifier.Text + syntax.TypeParameterList
                ));

        var implementedPartialTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) =>
                    syntax.IsPartialTypeDeclaration() &&
                    syntax is TypeDeclarationSyntax { BaseList: not null },
                static (context, _) => (context, syntax: (TypeDeclarationSyntax)context.Node)
            )
            .Combine(interfaceImplementationMap)
            .Select(static (state, _) => (
                state.Left.context,
                state.Left.syntax,
                state.Right.membersMap,
                state.Right.usings)
            )
            .Combine(partialTypeDeclarations)
            .Select(static (state, _) =>
            {
                TypeDeclarationSyntax? typeSyntax = state.Left.syntax;
                var key = typeSyntax.Identifier.Text + typeSyntax.TypeParameterList;
                return (
                    state.Left.context,
                    typeSyntax,
                    state.Left.membersMap,
                    state.Left.usings,
                    PartialParts: state.Right.GetValueOrDefault(key)
                );
            })
            .Where(static state => state.PartialParts is not null)
            .Select(static (state, cancellationToken) =>
            {
                var (context, typeSyntax, defaultInterfaceMembersMap, usings, partialParts) = state;

                string namespaceName = context.SemanticModel.GetDeclaredSymbol(typeSyntax)!
                    .ContainingNamespace.ToString();

                bool isNestedType = typeSyntax.IsNestedType();
                TypeDeclarationSyntax? parentOfType = null;
                if (isNestedType)
                {
                    parentOfType = (TypeDeclarationSyntax)typeSyntax.Parent!;
                }

                var semanticModel = context.SemanticModel.Compilation.GetSemanticModel(typeSyntax.SyntaxTree);
                var resolvedMembers = ResolveGenericMembers(
                    typeSyntax.BaseList?.Types ?? [],
                    defaultInterfaceMembersMap,
                    semanticModel,
                    cancellationToken
                );
                var existingMembers = partialParts.Append(typeSyntax).SelectMany(x => x.Members);

                typeSyntax = Semantics.FullyQualify(semanticModel, typeSyntax);
                typeSyntax = typeSyntax.WithPublicMembers(resolvedMembers.Except(existingMembers));

                TypeDeclarationSyntax partialType = TypeDeclarationUtil.CreatePartialType(typeSyntax);
                if (isNestedType)
                {
                    partialType = SyntaxFactory.TypeDeclaration(parentOfType!.Kind(), parentOfType.Identifier)
                        .WithModifiers(parentOfType.Modifiers)
                        .WithTypeParameterList(parentOfType.TypeParameterList)
                        .AddMembers(partialType)
                        .WithModifiers(parentOfType.Modifiers)
                        .AddModifierIfNotExists(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                        .NormalizeWhitespace();
                }

                return resolvedMembers.Count > 0 ? (partialType, namespaceName, usings) : default;
            })
            .Where(static typeSyntax => typeSyntax != default)
            .Collect();

        context.RegisterSourceOutput(implementedPartialTypes,
            (ctx, state) =>
            {
                var sb = new StringBuilder();

                foreach ((TypeDeclarationSyntax partialType, string namespaceName, var usings) in state)
                {
                    sb.AppendLine("// <auto-generated/>");
                    sb.AppendLine("#nullable enable");
                    sb.AppendLine("// new keyword may not hide any existing members but i dont care");
                    sb.AppendLine("#pragma warning disable CS0109");
                    var usingNamespaces =
                        usings.Select(x => x.ToString())
                            .Distinct()
                            .OrderBy(x => x.Contains("global"));
                    foreach (var usingNamespace in usingNamespaces)
                    {
                        sb.AppendLine(usingNamespace);
                    }

                    if (!string.IsNullOrEmpty(namespaceName))
                    {
                        sb.Append("namespace ");
                        sb.Append(namespaceName);
                        sb.AppendLine(";");
                    }

                    sb.AppendLine(partialType.ToString());
                    sb.AppendLine("#pragma warning restore CS0109");
                    var sourceCode = SourceText.From(sb.ToString(), Encoding.UTF8);
                    string checksum = FormatedChecksum(sourceCode, take: 4);
                    string safeParameterListName = partialType.TypeParameterList?
                        .ToString()
                        .Replace("<", "{")
                        .Replace(">", "}") ?? "";
                    string fileName =
                        $"{partialType.Identifier.Text}{safeParameterListName}_{checksum}.g.cs";
                    ctx.AddSource(fileName, sourceCode);
                    sb.Clear();
                }
            });
    }

    static ImmutableHashSet<MemberDeclarationSyntax> ResolveGenericMembers(
        SeparatedSyntaxList<BaseTypeSyntax> typeSyntaxes,
        ImmutableDictionary<InterfaceDeclarationSyntax, IReadOnlyCollection<MemberDeclarationSyntax>> interfaceMembers,
        SemanticModel semanticModel,
        CancellationToken cancellationToken = default)
    {
        var memberSignatureFromSyntax = MemberSignature.FromDeclarationSyntax;
        var compareByMemberSignature = EqualityComparer.CompareBy(memberSignatureFromSyntax);
        var allMembers = ImmutableHashSet.CreateBuilder(compareByMemberSignature);

        foreach (var kvp in interfaceMembers)
        {
            var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
            if (defaultMembers.Count == 0) continue;

            foreach (var baseTypeSyntax in typeSyntaxes)
            {
                if (cancellationToken.IsCancellationRequested)
                    return ImmutableHashSet<MemberDeclarationSyntax>.Empty;

                if (!interfaceSyntax.IsCompatibleType(baseTypeSyntax.Type)) continue;

                if (baseTypeSyntax.Type is GenericNameSyntax genericNameSyntax)
                {
                    defaultMembers = defaultMembers.ResolveGenerics(
                        genericNameSyntax,
                        interfaceSyntax
                    ).ToReadonlyCollection();
                }

                allMembers.UnionWith(defaultMembers);
            }
        }

        return allMembers.ToImmutable();
    }

    static IEnumerable<InterfaceDeclarationSyntax> ExtractParentInterfaces(TypeDeclarationSyntax syntax,
        ImmutableArray<InterfaceDeclarationSyntax> parentInterfaces,
        CancellationToken cancellationToken = default)
    {
        if (syntax.BaseList is not { Types: var types }) yield break;

        foreach (BaseTypeSyntax baseTypeSyntax in types)
        {
            if (cancellationToken.IsCancellationRequested) yield break;
            foreach (InterfaceDeclarationSyntax? interfaceSyntax in parentInterfaces)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                if (interfaceSyntax.IsCompatibleType(baseTypeSyntax.Type))
                    yield return interfaceSyntax;
            }
        }
    }
}