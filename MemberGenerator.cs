using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MemberGenerator;

[Generator]
public class MemberGenerator : IIncrementalGenerator
{
    const string Namespace                           = "MemberGenerator";
    const string GenerateDefaultMembersAttributeName = "GenerateDefaultMembers";
    const string PassthroughAttribute =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              internal class {{GenerateDefaultMembersAttributeName}}Attribute : System.Attribute
              {
              }
          };
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var sourceCode = SourceText.From(PassthroughAttribute, Encoding.UTF8);
            string checksum = FormatedChecksum(sourceCode, take: 4);
            string fileName = $"{GenerateDefaultMembersAttributeName}Attribute_{checksum}.g.cs";
            ctx.AddSource(fileName, sourceCode);
        });

        var interfacesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName<InterfaceDeclarationSyntax>(
                $"{Namespace}.{GenerateDefaultMembersAttributeName}Attribute"
            ).Collect();

        var usingDirectives = context.SyntaxProvider
            .CreateSyntaxProvider<UsingDirectiveSyntax>()
            .Collect();

        var interfaceImplementationMap = context.SyntaxProvider
            .CreateSyntaxProvider<InterfaceDeclarationSyntax>()
            .Combine(interfacesWithAttribute)
            .Select(static (state, cancellationToken) => (
                interfaceSyntax: state.Left,
                parentInterfaces: ExtractParentInterfaces(
                    syntax: state.Left,
                    parentInterfaces: state.Right,
                    cancellationToken: cancellationToken
                )
            ))
            .Combine(usingDirectives)
            .Select(static (state, _) =>
            {
                var ((interfaceSyntax, parentInterfaces), usings) = state;

                var enumeratedParentInterfaces = parentInterfaces.ToImmutableArray();
                var concatenation = enumeratedParentInterfaces.Append(interfaceSyntax).ToImmutableArray();
                var members = GetDefaultInterfaceMembers(concatenation).ToArray();
                var intersection = usings.Select(s => s.SyntaxTree).Intersect(members.Select(x => x.SyntaxTree));
                return (
                    interfaceSyntax,
                    parentInterfaces: enumeratedParentInterfaces,
                    members: members.AsEnumerable(),
                    usings: usings.Where(x => intersection.Contains(x.SyntaxTree)).ToImmutableArray()
                );
            })
            .Collect()
            .Select(static (state, _) =>
            {
                var members = state.ToImmutableDictionary(x => x.interfaceSyntax, x => x.members);
                var parents = state.SelectMany(s => s.parentInterfaces);
                var parentMembers = parents.Select(s => (s, s.GetDefaultInterfaceMembers()));
                var membersMap = members.Combine(parentMembers);
                return (membersMap, usings: state.SelectMany(x => x.usings).ToImmutableArray());
            });

        var partialTypeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) => syntax.IsPartialTypeDeclaration(),
                static (context, _) => (TypeDeclarationSyntax)context.Node
            )
            .Collect()
            .Select(static (syntax, _) => syntax.GroupByToImmutableDictionary(syntax =>
                syntax.Identifier.Text + syntax.TypeParameterList
            ));

        var implementedPartialTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) =>
                    syntax.IsPartialTypeDeclaration() &&
                    syntax is TypeDeclarationSyntax { BaseList: not null },
                static (context, _) => (TypeDeclarationSyntax)context.Node
            )
            .Combine(interfaceImplementationMap)
            .Select(static (state, _) => (implementation: state.Left, state.Right.membersMap, state.Right.usings))
            .Combine(partialTypeDeclarations)
            .Select(static (state, _) =>
            {
                var implementation = state.Left.implementation;
                var key = implementation.Identifier.Text + implementation.TypeParameterList;
                return (
                    implementation,
                    state.Left.membersMap,
                    state.Left.usings,
                    PartialParts: state.Right.GetValueOrDefault(key)
                );
            })
            .Where(static state => state.PartialParts is not null)
            .Select(static (state, cancellationToken) =>
            {
                var (typeSyntax, defaultInterfaceMembersMap, usings, partialParts) = state;

                var namespaceName = typeSyntax.GetNamespace();
                var notImplementedMembers = ExtractNotImplementedMembers(
                    typeSyntax,
                    partialParts,
                    defaultInterfaceMembersMap,
                    cancellationToken
                );

                typeSyntax = typeSyntax.WithInterfaceMembers(notImplementedMembers);
                var partialType = typeSyntax.CreatePartialType();
                return notImplementedMembers.Length > 0 ? (partialType, namespaceName, usings) : default;
            })
            .Where(static typeSyntax => typeSyntax != default)
            .Collect();

        context.RegisterSourceOutput(implementedPartialTypes,
            (ctx, state) =>
            {
                var sb = new StringBuilder("// <auto-generated/>\n");

                foreach (var usingNamespace in state.SelectMany(x => x.usings)
                             .OrderBy(u => !u.ToString().Contains("global")))
                {
                    sb.AppendLine(usingNamespace.ToString());
                }

                foreach (var namespaceName in state.Select(x => x.namespaceName).ToImmutableHashSet())
                {
                    if (string.IsNullOrEmpty(namespaceName)) continue;
                    sb.Append("namespace ");
                    sb.Append(namespaceName);
                    sb.AppendLine(";");
                }

                foreach (var item in state)
                {
                    sb.AppendLine(item.partialType.ToString());
                }

                var sourceCode = SourceText.From(sb.ToString(), Encoding.UTF8);
                string checksum = FormatedChecksum(sourceCode, take: 4);
                string fileName = $"{Namespace}_{checksum}.g.cs";
                ctx.AddSource(fileName, sourceCode);
            });
    }

    static ImmutableArray<MemberDeclarationSyntax> ExtractNotImplementedMembers(TypeDeclarationSyntax typeSyntax,
        IEnumerable<TypeDeclarationSyntax>? partialParts,
        ImmutableDictionary<InterfaceDeclarationSyntax, IEnumerable<MemberDeclarationSyntax>> interfaceMembers,
        CancellationToken cancellationToken = default)
    {
        var memberSignatureFromSyntax = MemberSignature.FromDeclarationSyntax;
        var compareByMemberSignature = EqualityComparer.Select(memberSignatureFromSyntax);
        var allMembers = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();
        var membersOfType = partialParts!.SelectMany(x => x.Members).Concat(typeSyntax.Members).ToArray();
        foreach (var baseTypeSyntax in typeSyntax.BaseList!.Types)
        {
            if (cancellationToken.IsCancellationRequested) break;
            foreach (var kvp in interfaceMembers)
            {
                var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
                if (cancellationToken.IsCancellationRequested) break;

                if (interfaceSyntax.IsDeclarationOf(baseTypeSyntax))
                {
                    var resolvedMembers = defaultMembers.ResolveGenerics(baseTypeSyntax, interfaceSyntax);
                    allMembers.AddRange(resolvedMembers.Except(membersOfType, compareByMemberSignature));
                }
            }
        }

        return allMembers.ToImmutable();
    }

    static IEnumerable<InterfaceDeclarationSyntax> ExtractParentInterfaces(TypeDeclarationSyntax syntax,
        ImmutableArray<InterfaceDeclarationSyntax> parentInterfaces,
        CancellationToken cancellationToken = default)
    {
        if (syntax.BaseList is not { Types: var types }) yield break;

        foreach (var baseTypeSyntax in types)
        {
            if (cancellationToken.IsCancellationRequested) yield break;
            foreach (var interfaceSyntax in parentInterfaces)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                if (interfaceSyntax.IsDeclarationOf(baseTypeSyntax))
                    yield return interfaceSyntax;
            }
        }
    }

    static IEnumerable<MemberDeclarationSyntax> GetDefaultInterfaceMembers(
        IEnumerable<InterfaceDeclarationSyntax> interfaceDeclarationSyntax) =>
        interfaceDeclarationSyntax.SelectMany(static state => state.GetDefaultInterfaceMembers());
}