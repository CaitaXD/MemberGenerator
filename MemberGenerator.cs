using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using MemberGenerator.Ex;
using MemberGenerator.Factory;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MemberGenerator;

[Generator]
public class MemberGenerator : IIncrementalGenerator
{
    const string Namespace                           = "MemberGenerator";
    const string GenerateDefaultMembersAttributeName = "GenerateDefaultMembers";
    const string PassthroughAttribute =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              internal class {{GenerateDefaultMembersAttributeName}}Attribute : System.Attribute
              {
              }
          };
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var sourceCode = SourceText.From(PassthroughAttribute, Encoding.UTF8);
            string checksum = FormatedChecksum(sourceCode, take: 4);
            string fileName = $"{GenerateDefaultMembersAttributeName}Attribute_{checksum}.g.cs";
            ctx.AddSource(fileName, sourceCode);
        });

        var interfacesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName<InterfaceDeclarationSyntax>(
                $"{Namespace}.{GenerateDefaultMembersAttributeName}Attribute"
            ).Collect();

        var usingDirectives = context.SyntaxProvider
            .CreateSyntaxProvider<UsingDirectiveSyntax>()
            .Collect();

        var interfaceImplementationMap = context.SyntaxProvider
            .CreateSyntaxProvider<InterfaceDeclarationSyntax>()
            .Combine(interfacesWithAttribute)
            .Select(static (state, cancellationToken) => (
                interfaceSyntax: state.Left,
                parentInterfaces: ExtractParentInterfaces(
                    syntax: state.Left,
                    parentInterfaces: state.Right,
                    cancellationToken: cancellationToken
                )
            ))
            .Combine(usingDirectives)
            .Select(static (state, _) =>
            {
                var ((interfaceSyntax, parentInterfaces), usings) = state;
                var enumeratedParentInterfaces = parentInterfaces.ToReadonlyCollection();
                var concatenation = enumeratedParentInterfaces.Append(interfaceSyntax);
                var members = concatenation.GetDefaultMembers().ToReadonlyCollection();
                var intersection = usings.Select(s => s.SyntaxTree).Intersect(members.Select(x => x.SyntaxTree));
                return (
                    interfaceSyntax,
                    parentInterfaces: enumeratedParentInterfaces,
                    members,
                    usings: usings.Where(x => intersection.Contains(x.SyntaxTree)).ToImmutableArray()
                );
            })
            .Collect()
            .Select(static (state, _) =>
            {
                var members = state.ToImmutableDictionary(x => x.interfaceSyntax, x => x.members);
                var parents = state.SelectMany(s => s.parentInterfaces);
                var parentMembers = parents.Select(s => (s, s.GetDefaultMembers().ToReadonlyCollection()));
                var membersMap = members.Combine(parentMembers);
                return (membersMap, usings: state.SelectMany(x => x.usings).ToImmutableArray());
            });

        var partialTypeDeclarations =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (syntax, _) => syntax.IsPartialTypeDeclaration(),
                    static (context, _) => (TypeDeclarationSyntax)context.Node
                )
                .Collect()
                .Select(static (syntax, _) => syntax.GroupByToImmutableDictionary(syntax =>
                    syntax.Identifier.Text + syntax.TypeParameterList
                ));

        var implementedPartialTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) =>
                    syntax.IsPartialTypeDeclaration() &&
                    syntax is TypeDeclarationSyntax { BaseList: not null },
                static (context, _) => (context, syntax: (TypeDeclarationSyntax)context.Node)
            )
            .Combine(interfaceImplementationMap)
            .Select(static (state, _) => (
                state.Left.context,
                state.Left.syntax,
                state.Right.membersMap,
                state.Right.usings)
            )
            .Combine(partialTypeDeclarations)
            .Select(static (state, _) =>
            {
                TypeDeclarationSyntax? typeSyntax = state.Left.syntax;
                var key = typeSyntax.Identifier.Text + typeSyntax.TypeParameterList;
                return (
                    state.Left.context,
                    typeSyntax,
                    state.Left.membersMap,
                    state.Left.usings,
                    PartialParts: state.Right.GetValueOrDefault(key)
                );
            })
            .Where(static state => state.PartialParts is not null)
            .Select(static (state, cancellationToken) =>
            {
                var (context, typeSyntax, defaultInterfaceMembersMap, usings, partialParts) = state;
                bool isNestedType = typeSyntax.IsNestedType();
                TypeDeclarationSyntax? parentOfType = null;
                if (isNestedType)
                {
                    parentOfType = (TypeDeclarationSyntax)typeSyntax.Parent!;
                }

                var namespaceName = typeSyntax.GetNamespace();
                var notImplementedMembers = ExtractNotImplementedMembers(
                    context,
                    typeSyntax,
                    partialParts,
                    defaultInterfaceMembersMap,
                    cancellationToken
                );

                typeSyntax = typeSyntax.WithPublicMembers(notImplementedMembers);
                TypeDeclarationSyntax partialType = TypeDeclarationSyntaxFactory.CreatePartialType(typeSyntax);
                if (isNestedType)
                {
                    partialType = SyntaxFactory.TypeDeclaration(parentOfType!.Kind(), parentOfType.Identifier)
                        .WithModifiers(parentOfType.Modifiers)
                        .WithTypeParameterList(parentOfType.TypeParameterList)
                        .AddMembers(partialType)
                        .WithModifiers(parentOfType.Modifiers)
                        .AddModifierIfNotExists(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                        .NormalizeWhitespace();
                }

                return notImplementedMembers.Length > 0 ? (partialType, namespaceName, usings) : default;
            })
            .Where(static typeSyntax => typeSyntax != default)
            .Collect();

        context.RegisterSourceOutput(implementedPartialTypes,
            (ctx, state) =>
            {
                var sb = new StringBuilder();

                foreach ((TypeDeclarationSyntax partialType, string? namespaceName, var usings) in state)
                {
                    sb.AppendLine("// <auto-generated/>");
                    sb.AppendLine("#nullable enable");
                    sb.AppendLine("// new keyword may not hide any existing members but i dont care");
                    sb.AppendLine("#pragma warning disable CS0109");
                    var usingNamespaces =
                        usings.Select(x => x.ToString())
                            .Distinct()
                            .OrderBy(x => x.Contains("global"));
                    foreach (var usingNamespace in usingNamespaces)
                    {
                        sb.AppendLine(usingNamespace);
                    }

                    if (!string.IsNullOrEmpty(namespaceName))
                    {
                        sb.Append("namespace ");
                        sb.Append(namespaceName);
                        sb.AppendLine(";");
                    }

                    sb.AppendLine(partialType.ToString());
                    sb.AppendLine("#pragma warning restore CS0109");
                    var sourceCode = SourceText.From(sb.ToString(), Encoding.UTF8);
                    string checksum = FormatedChecksum(sourceCode, take: 4);
                    string safeParameterListName = partialType.TypeParameterList?
                        .ToString()
                        .Replace("<", "{")
                        .Replace(">", "}") ?? "";
                    string fileName =
                        $"{partialType.Identifier.Text}{safeParameterListName}_{checksum}.g.cs";
                    ctx.AddSource(fileName, sourceCode);
                    Console.WriteLine(fileName);
                    Console.WriteLine(sourceCode);
                    sb.Clear();
                }
            });
    }

    static ImmutableArray<MemberDeclarationSyntax> ExtractNotImplementedMembers(
        GeneratorSyntaxContext context,
        TypeDeclarationSyntax typeSyntax,
        IEnumerable<TypeDeclarationSyntax>? partialParts,
        ImmutableDictionary<InterfaceDeclarationSyntax, IReadOnlyCollection<MemberDeclarationSyntax>> interfaceMembers,
        CancellationToken cancellationToken = default)
    {
        var memberSignatureFromSyntax = MemberSignature.FromDeclarationSyntax;
        var compareByMemberSignature = EqualityComparer.Select(memberSignatureFromSyntax);
        ImmutableArray<MemberDeclarationSyntax>.Builder allMembers = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();
        var membersOfType = partialParts!.SelectMany(x => x.Members).Concat(typeSyntax.Members).ToArray();

        SemanticModel semanticModel = context.SemanticModel.Compilation.GetSemanticModel(typeSyntax.SyntaxTree);
        INamedTypeSymbol typeSymbol = semanticModel.GetDeclaredSymbol(typeSyntax)!;

        // foreach (var kvp in interfaceMembers)
        // {
        //     var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
        //     if (defaultMembers.Count == 0) continue;
        //
        //     string interfaceName = $"{interfaceSyntax.Identifier.Text}{interfaceSyntax.TypeParameterList}";
        //     if (typeSymbol.ImplementsDirectly(interfaceName))
        //     {
        //         if (typeSyntax is { BaseList: {} baseList })
        //         {
        //             foreach (var basType in baseList.Types)
        //             {
        //                 if (basType.Type is GenericNameSyntax genericNameSyntax)
        //                 {
        //                     defaultMembers = defaultMembers
        //                         .ResolveGenerics(genericNameSyntax, interfaceSyntax)
        //                         .ToReadonlyCollection();
        //                 }
        //             }
        //
        //             allMembers.AddRange(defaultMembers.Except(membersOfType, compareByMemberSignature));
        //         }
        //     }
        // }

        foreach (BaseTypeSyntax baseTypeSyntax in typeSyntax.BaseList!.Types)
        {
            if (cancellationToken.IsCancellationRequested) return ImmutableArray<MemberDeclarationSyntax>.Empty;
            foreach (var kvp in interfaceMembers)
            {
                var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
                if (cancellationToken.IsCancellationRequested) return ImmutableArray<MemberDeclarationSyntax>.Empty;
        
                if (interfaceSyntax.NameEquals(baseTypeSyntax.Type))
                {
                    if (baseTypeSyntax.Type is GenericNameSyntax genericNameSyntax)
                        defaultMembers = defaultMembers.ResolveGenerics(genericNameSyntax
                                , interfaceSyntax)
                            .ToReadonlyCollection();
                    allMembers.AddRange(defaultMembers.Except(membersOfType, compareByMemberSignature));
                }
            }
        }

        return allMembers.ToImmutable();
    }

    static IEnumerable<InterfaceDeclarationSyntax> ExtractParentInterfaces(TypeDeclarationSyntax syntax,
        ImmutableArray<InterfaceDeclarationSyntax> parentInterfaces,
        CancellationToken cancellationToken = default)
    {
        if (syntax.BaseList is not { Types: var types }) yield break;

        foreach (BaseTypeSyntax baseTypeSyntax in types)
        {
            if (cancellationToken.IsCancellationRequested) yield break;
            foreach (InterfaceDeclarationSyntax? interfaceSyntax in parentInterfaces)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                if (interfaceSyntax.NameEquals(baseTypeSyntax.Type))
                    yield return interfaceSyntax;
            }
        }
    }
}