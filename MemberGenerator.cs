using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MemberGenerator;

[Generator]
public class MemberGenerator : IIncrementalGenerator
{
    const string Namespace                           = "MemberGenerator";
    const string GenerateDefaultMembersAttributeName = "GenerateDefaultMembers";
    const string PassthroughAttribute =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              public class {{GenerateDefaultMembersAttributeName}}Attribute : System.Attribute
              {
              }
          };
          """;

//     const string DeriveAttributeName = "Derive";
//      const string DeriveAttribute =
//          $$"""
//            // <auto-generated/>
//            namespace {{Namespace}}
//            {
//                [System.AttributeUsage(System.AttributeTargets.Interface)]
//                public class {{DeriveAttributeName}}Attribute : System.Attribute
//                {
//                }
//            };
//            """;


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var sourceCode = SourceText.From(PassthroughAttribute, Encoding.UTF8);
            string checksum = FormatedChecksum(sourceCode, take: 4);
            string fileName = $"{GenerateDefaultMembersAttributeName}Attribute_{checksum}.g.cs";
            ctx.AddSource(fileName, sourceCode);
        });

        var interfacesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName<InterfaceDeclarationSyntax>(
                $"{Namespace}.{GenerateDefaultMembersAttributeName}Attribute"
            ).Collect();

        var interfaceImplementationMap = context.SyntaxProvider
            .CreateSyntaxProvider<InterfaceDeclarationSyntax>()
            .Combine(interfacesWithAttribute)
            .Select(static (state, cancellationToken) => (
                interfaceSyntax: state.Left,
                parentInterfaces: ExtractParentInterfaces(
                    syntax: state.Left,
                    parentInterfaces: state.Right,
                    cancellationToken: cancellationToken
                )
            ))
            .Where(static state => state.parentInterfaces.Any())
            .Select(static (state, _) => (
                state.interfaceSyntax,
                state.parentInterfaces,
                members: GetDefaultInterfaceMembers(state.parentInterfaces)
            ))
            .Collect()
            .Select(static (state, _) =>
            {
                var members = state.ToImmutableDictionary(x => x.interfaceSyntax, x => x.members);
                var parents = state.SelectMany(s => s.parentInterfaces);
                var parentMembers = parents.Select(s => (s, s.GetDefaultInterfaceMembers()));
                return members.Combine(parentMembers);
            });

        var partialTypeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) => syntax.IsPartialTypeDeclaration(),
                static (context, _) => (TypeDeclarationSyntax)context.Node
            )
            .Collect()
            .Select(static (syntax, _) => syntax.GroupByToImmutableDictionary(syntax => 
                syntax.Identifier.Text + syntax.TypeParameterList
            ));

        var implementedPartialTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) =>
                    syntax.IsPartialTypeDeclaration() &&
                    syntax is TypeDeclarationSyntax { BaseList: not null },
                static (context, _) => (TypeDeclarationSyntax)context.Node
            )
            .Combine(interfaceImplementationMap)
            .Select(static (state, _) => (Implementation: state.Left, Map: state.Right))
            .Combine(partialTypeDeclarations)
            .Select(static (state, _) =>
            {
                var implementation = state.Left.Implementation;
                var key = implementation.Identifier.Text + implementation.TypeParameterList;
                return (
                    implementation,
                    state.Left.Map,
                    PartialParts: state.Right.GetValueOrDefault(key));
            })
            .Where(static state => state.PartialParts is not null)
            .Select(static (state, cancellationToken) =>
            {
                var (typeSyntax, defaultInterfaceMembersMap, partialParts) = state;

                var namespaceName = typeSyntax.GetNamespace();
                var notImplementedMembers = ExtractNotImplementedMembers(
                    typeSyntax,
                    partialParts,
                    defaultInterfaceMembersMap,
                    cancellationToken
                );
                typeSyntax = typeSyntax.WithInterfaceMembers(notImplementedMembers);
                var partialType = typeSyntax.CreatePartialType();
                return notImplementedMembers.Length > 0 ? (partialType, namespaceName) : default;
            })
            .Where(static typeSyntax => typeSyntax != default)
            .Collect();

        context.RegisterSourceOutput(implementedPartialTypes,
            (ctx, state) =>
            {
                var sb = new StringBuilder("// <auto-generated/>\n");
                foreach (var namespaceName in state.Select(x => x.namespaceName).ToImmutableHashSet())
                {
                    if (string.IsNullOrEmpty(namespaceName)) continue;
                    sb.Append("namespace ");
                    sb.Append(namespaceName);
                    sb.AppendLine(";");
                }

                foreach (var item in state)
                    sb.AppendLine(item.partialType.ToString());

                var sourceCode = SourceText.From(sb.ToString(), Encoding.UTF8);
                string checksum = FormatedChecksum(sourceCode, take: 4);
                string fileName = $"{Namespace}_{checksum}.g.cs";
                ctx.AddSource(fileName, sourceCode);
            });
    }

    static ImmutableArray<MemberDeclarationSyntax> ExtractNotImplementedMembers(TypeDeclarationSyntax typeSyntax,
        IEnumerable<TypeDeclarationSyntax>? partialParts,
        ImmutableDictionary<InterfaceDeclarationSyntax, IEnumerable<MemberDeclarationSyntax>> interfaceMembers,
        CancellationToken cancellationToken = default)
    {
        var memberSignatureFromSyntax = MemberSignature.FromDeclarationSyntax;
        var compareByMemberSignature = EqualityComparer.Select(memberSignatureFromSyntax);
        var allMembers = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();
        var membersOfType = partialParts!.SelectMany(x => x.Members).Concat(typeSyntax.Members).ToArray();
        foreach (var baseTypeSyntax in typeSyntax.BaseList!.Types)
        {
            if (cancellationToken.IsCancellationRequested) break;
            foreach (var kvp in interfaceMembers)
            {
                var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
                if (cancellationToken.IsCancellationRequested) break;
                if (interfaceSyntax.IsDeclarationOf(baseTypeSyntax))
                {
                    var resolvedMembers = defaultMembers.ResolveGenerics(baseTypeSyntax, interfaceSyntax);
                    allMembers.AddRange(resolvedMembers.Except(membersOfType, compareByMemberSignature));
                }
            }
        }

        return allMembers.ToImmutable();
    }

    static IEnumerable<InterfaceDeclarationSyntax> ExtractParentInterfaces(TypeDeclarationSyntax syntax,
        ImmutableArray<InterfaceDeclarationSyntax> parentInterfaces,
        CancellationToken cancellationToken = default)
    {
        if (syntax.BaseList is not { Types: var types }) yield break;

        foreach (var baseTypeSyntax in types)
        {
            if (cancellationToken.IsCancellationRequested) yield break;
            foreach (var interfaceSyntax in parentInterfaces)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                if (interfaceSyntax.IsDeclarationOf(baseTypeSyntax))
                    yield return interfaceSyntax;
            }
        }
    }

    static IEnumerable<MemberDeclarationSyntax> GetDefaultInterfaceMembers(
        IEnumerable<InterfaceDeclarationSyntax> interfaceDeclarationSyntax) =>
        interfaceDeclarationSyntax.SelectMany(static state => state.GetDefaultInterfaceMembers());

    static string FormatedChecksum(SourceText sourceText, int? take = null)
    {
        var sb = new StringBuilder();
        foreach (var b in sourceText.GetChecksum())
            sb.Append(b.ToString("x2"));

        if (take.HasValue) sb.Length = take.Value;
        return sb.ToString();
    }
}