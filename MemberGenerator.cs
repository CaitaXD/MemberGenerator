using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using MemberGenerator.Ex;
using MemberGenerator.Factory;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MemberGenerator;

[Generator]
public class MemberGenerator : IIncrementalGenerator
{
    const string Namespace                           = "MemberGenerator";
    const string GenerateDefaultMembersAttributeName = "GenerateDefaultMembers";
    const string PassthroughAttribute =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              internal class {{GenerateDefaultMembersAttributeName}}Attribute : System.Attribute
              {
              }
          };
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var sourceCode = SourceText.From(PassthroughAttribute, Encoding.UTF8);
            string checksum = FormatedChecksum(sourceCode, take: 4);
            string fileName = $"{GenerateDefaultMembersAttributeName}Attribute_{checksum}.g.cs";
            ctx.AddSource(fileName, sourceCode);
        });

        var interfacesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName<InterfaceDeclarationSyntax>(
                $"{Namespace}.{GenerateDefaultMembersAttributeName}Attribute"
            ).Collect();

        var usingDirectives = context.SyntaxProvider
            .CreateSyntaxProvider<UsingDirectiveSyntax>()
            .Collect();

        var interfaceImplementationMap = context.SyntaxProvider
            .CreateSyntaxProvider<InterfaceDeclarationSyntax>()
            .Combine(interfacesWithAttribute)
            .Select(static (state, cancellationToken) => (
                interfaceSyntax: state.Left,
                parentInterfaces: ExtractParentInterfaces(
                    syntax: state.Left,
                    parentInterfaces: state.Right,
                    cancellationToken: cancellationToken
                )
            ))
            .Combine(usingDirectives)
            .Select(static (state, _) =>
            {
                var ((interfaceSyntax, parentInterfaces), usings) = state;

                var enumeratedParentInterfaces = parentInterfaces.ToImmutableArray();
                var concatenation = enumeratedParentInterfaces.Append(interfaceSyntax).ToImmutableArray();
                var members = GetDefaultInterfaceMembers(concatenation).ToArray();
                var intersection = usings.Select(s => s.SyntaxTree).Intersect(members.Select(x => x.SyntaxTree));
                return (
                    interfaceSyntax,
                    parentInterfaces: enumeratedParentInterfaces,
                    members: members.AsEnumerable(),
                    usings: usings.Where(x => intersection.Contains(x.SyntaxTree)).ToImmutableArray()
                );
            })
            .Collect()
            .Select(static (state, _) =>
            {
                var members = state.ToImmutableDictionary(x => x.interfaceSyntax, x => x.members);
                var parents = state.SelectMany(s => s.parentInterfaces);
                var parentMembers = parents.Select(s => (s, s.GetDefaultMembers()));
                var membersMap = members.Combine(parentMembers);
                return (membersMap, usings: state.SelectMany(x => x.usings).ToImmutableArray());
            });

        var partialTypeDeclarations =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (syntax, _) => syntax.IsPartialTypeDeclaration(),
                    static (context, _) => (TypeDeclarationSyntax)context.Node
                )
                .Collect()
                .Select(static (syntax, _) => syntax.GroupByToImmutableDictionary(syntax =>
                    syntax.Identifier.Text + syntax.TypeParameterList
                ));

        var implementedPartialTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntax, _) =>
                    syntax.IsPartialTypeDeclaration() &&
                    syntax is TypeDeclarationSyntax { BaseList: not null },
                static (context, _) => (TypeDeclarationSyntax)context.Node
            )
            .Combine(interfaceImplementationMap)
            .Select(static (state, _) => (implementation: state.Left, state.Right.membersMap, state.Right.usings))
            .Combine(partialTypeDeclarations)
            .Select(static (state, _) =>
            {
                var typeSyntax = state.Left.implementation;
                var key = typeSyntax.Identifier.Text + typeSyntax.TypeParameterList;
                return (
                    typeSyntax,
                    state.Left.membersMap,
                    state.Left.usings,
                    PartialParts: state.Right.GetValueOrDefault(key)
                );
            })
            .Where(static state => state.PartialParts is not null)
            .Select(static (state, cancellationToken) =>
            {
                var (typeSyntax, defaultInterfaceMembersMap, usings, partialParts) = state;
                bool isNestedType = typeSyntax.IsNestedType();
                TypeDeclarationSyntax? parentOfType = null;
                if (isNestedType)
                {
                    parentOfType = (TypeDeclarationSyntax)typeSyntax.Parent!;
                }

                var namespaceName = typeSyntax.GetNamespace();
                var notImplementedMembers = ExtractNotImplementedMembers(
                    typeSyntax,
                    partialParts,
                    defaultInterfaceMembersMap,
                    cancellationToken
                );

                typeSyntax = typeSyntax.WithPublicMembers(notImplementedMembers);
                var partialType = TypeDeclarationSyntaxFactory.CreatePartialType(typeSyntax);
                if (isNestedType)
                {
                    partialType = SyntaxFactory.TypeDeclaration(parentOfType!.Kind(), parentOfType.Identifier)
                        .WithModifiers(parentOfType.Modifiers)
                        .WithTypeParameterList(parentOfType.TypeParameterList)
                        .AddMembers(partialType)
                        .WithModifiers(parentOfType.Modifiers)
                        .AddModifierIfNotExists(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                        .NormalizeWhitespace();
                }

                return notImplementedMembers.Length > 0 ? (partialType, namespaceName, usings) : default;
            })
            .Where(static typeSyntax => typeSyntax != default)
            .Collect();

        context.RegisterSourceOutput(implementedPartialTypes,
            (ctx, state) =>
            {
                var sb = new StringBuilder();

                foreach ((var partialType, string? namespaceName, var usings) in state)
                {
                    sb.AppendLine("// <auto-generated/>");
                    sb.AppendLine("#nullable enable");
                    sb.AppendLine("// new keyword may not hide any existing members but i dont care");
                    sb.AppendLine("#pragma warning disable CS0109");
                    foreach (var usingNamespace in usings.OrderBy(u => !u.ToString().Contains("global")).Distinct())
                    {
                        sb.AppendLine(usingNamespace.ToString());
                    }

                    if (!string.IsNullOrEmpty(namespaceName))
                    {
                        sb.Append("namespace ");
                        sb.Append(namespaceName);
                        sb.AppendLine(";");
                    }

                    sb.AppendLine(partialType.ToString());
                    sb.AppendLine("#pragma warning restore CS0109");
                    var sourceCode = SourceText.From(sb.ToString(), Encoding.UTF8);
                    string checksum = FormatedChecksum(sourceCode, take: 4);
                    string safeParameterListName = partialType.TypeParameterList?
                        .ToString()
                        .Replace("<", "{")
                        .Replace(">", "}") ?? "";
                    string fileName =
                        $"{partialType.Identifier.Text}{safeParameterListName}_{checksum}.g.cs";
                    ctx.AddSource(fileName, sourceCode);
                    sb.Clear();
                }
            });
    }

    static ImmutableArray<MemberDeclarationSyntax> ExtractNotImplementedMembers(
        TypeDeclarationSyntax typeSyntax,
        IEnumerable<TypeDeclarationSyntax>? partialParts,
        ImmutableDictionary<InterfaceDeclarationSyntax, IEnumerable<MemberDeclarationSyntax>> interfaceMembers,
        CancellationToken cancellationToken = default)
    {
        var memberSignatureFromSyntax = MemberSignature.FromDeclarationSyntax;
        var compareByMemberSignature = EqualityComparer.Select(memberSignatureFromSyntax);
        var allMembers = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();
        var membersOfType = partialParts!.SelectMany(x => x.Members).Concat(typeSyntax.Members).ToArray();
        foreach (var baseTypeSyntax in typeSyntax.BaseList!.Types)
        {
            if (cancellationToken.IsCancellationRequested) return ImmutableArray<MemberDeclarationSyntax>.Empty;
            foreach (var kvp in interfaceMembers)
            {
                var (interfaceSyntax, defaultMembers) = (kvp.Key, kvp.Value);
                if (cancellationToken.IsCancellationRequested) return ImmutableArray<MemberDeclarationSyntax>.Empty;

                if (interfaceSyntax.DirectlyImplements(baseTypeSyntax.Type))
                {
                    if (baseTypeSyntax.Type is GenericNameSyntax genericNameSyntax)
                        defaultMembers = defaultMembers.ResolveGenerics(genericNameSyntax, interfaceSyntax);
                    allMembers.AddRange(defaultMembers.Except(membersOfType, compareByMemberSignature));
                }
            }
        }

        return allMembers.ToImmutable();
    }

    static IEnumerable<InterfaceDeclarationSyntax> ExtractParentInterfaces(TypeDeclarationSyntax syntax,
        ImmutableArray<InterfaceDeclarationSyntax> parentInterfaces,
        CancellationToken cancellationToken = default)
    {
        if (syntax.BaseList is not { Types: var types }) yield break;

        foreach (var baseTypeSyntax in types)
        {
            if (cancellationToken.IsCancellationRequested) yield break;
            foreach (var interfaceSyntax in parentInterfaces)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                if (interfaceSyntax.DirectlyImplements(baseTypeSyntax.Type))
                    yield return interfaceSyntax;
            }
        }
    }

    static IEnumerable<MemberDeclarationSyntax> GetDefaultInterfaceMembers(
        IEnumerable<InterfaceDeclarationSyntax> interfaceDeclarationSyntax) =>
        interfaceDeclarationSyntax.SelectMany(static state => state.GetDefaultMembers());
}